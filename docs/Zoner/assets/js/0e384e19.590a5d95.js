"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[976],{7879:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"intro","title":"ZoneConfig","description":"ZoneConfig defines how a Zone behaves at runtime\u2014how it detects objects, how often it updates, and what simulation or execution model it uses.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/docs/Zoner/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/skyriverstudios/Zoner/edit/main/docs/intro.md","tags":[],"version":"current","frontMatter":{"title":"ZoneConfig"},"sidebar":"defaultSidebar"}');var s=t(4848),r=t(8453);const o={title:"ZoneConfig"},d="ZoneConfig Overview",l={},c=[{value:"Default Zone Configuration",id:"default-zone-configuration",level:2},{value:"Detection Settings",id:"detection-settings",level:2},{value:"DetectionMethod",id:"detectionmethod",level:3},{value:"DetectionMode",id:"detectionmode",level:3},{value:"DetectionCoverage",id:"detectioncoverage",level:3},{value:"Detection Extras",id:"detection-extras",level:3},{value:"Execution &amp; Simulation Behavior",id:"execution--simulation-behavior",level:2},{value:"Execution",id:"execution",level:3},{value:"Simulation",id:"simulation",level:3},{value:"Bounds Configuration",id:"bounds-configuration",level:2},{value:"Bounds",id:"bounds",level:3},{value:"Update/Detection Frequency",id:"updatedetection-frequency",level:2},{value:"Rate",id:"rate",level:3},{value:"Event Listening &amp; Manual Stepping",id:"event-listening--manual-stepping",level:2},{value:"Rate",id:"rate-1",level:3},{value:"Example ZoneConfig Usage",id:"example-zoneconfig-usage",level:2},{value:"Summary",id:"summary",level:2}];function a(e){const n={br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"zoneconfig-overview",children:"ZoneConfig Overview"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ZoneConfig"})," defines how a Zone behaves at runtime\u2014how it detects objects, how often it updates, and what simulation or execution model it uses.",(0,s.jsx)(n.br,{}),"\n","It combines several configurable Enums to control performance, accuracy, and simulation timing."]}),"\n",(0,s.jsxs)(n.p,{children:["If any field is left ",(0,s.jsx)(n.strong,{children:"blank"}),", the system automatically applies the ",(0,s.jsx)(n.strong,{children:"default configuration"})," below."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"default-zone-configuration",children:"Default Zone Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"-- Create a default Configs table constant:\nlocal DEFAULT_ZONE_CONFIG = {\n\tDetectionCoverage = Enums.DetectionCoverage.Center,\n\tDetectionMethod   = Enums.DetectionMethod.Automatic,\n\tDetectionMode     = Enums.DetectionMode.Point,\n\tSimulation        = Enums.Simulation.PostSimulation,\n\tExecution         = Enums.Execution.Parallel,\n\tBounds            = Enums.Bounds.Automatic,\n\tRate              = Enums.Rate.Fast,\n\n\tNoZonePartPropertyListening = false,\n\tNoZonePartAddedListening    = false,\n\tManualStepping              = false,\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"detection-settings",children:"Detection Settings"}),"\n",(0,s.jsx)(n.h3,{id:"detectionmethod",children:"DetectionMethod"}),"\n",(0,s.jsx)(n.p,{children:"Determines the algorithm used to detect objects within the Zone volume."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Automatic"})}),(0,s.jsx)(n.td,{children:"Automatically selects the most suitable detection method based on the Zone container's shape and complexity."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Efficient"})}),(0,s.jsx)(n.td,{children:"Fastest option. Uses raw CFrame and Size math to test inclusion in the Zone bounds. Ideal for simple box/sphere volumes."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Simple"})}),(0,s.jsxs)(n.td,{children:["Balanced mode using ",(0,s.jsx)(n.code,{children:"GetPartBoundsInBox"})," or ",(0,s.jsx)(n.code,{children:"GetPartBoundsInRadius"})," under the hood. Provides solid accuracy at modest performance cost."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Complex"})}),(0,s.jsxs)(n.td,{children:["Highest accuracy. Uses detailed ",(0,s.jsx)(n.code,{children:"GetPartsInPart"})," or mesh-aware tests. May create placeholder parts if the ZoneContainer is empty."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"detectionmode",children:"DetectionMode"}),"\n",(0,s.jsxs)(n.p,{children:["Controls ",(0,s.jsx)(n.em,{children:"how much"}),' of a target must be inside the Zone to count as "within."']}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Full"})}),(0,s.jsx)(n.td,{children:"The entire target must be inside or outside before triggering entrance or exit."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Touch"})}),(0,s.jsxs)(n.td,{children:["Any overlap or intersection with the Zone boundary counts. (Does ",(0,s.jsx)(n.strong,{children:"not"})," use ",(0,s.jsx)(n.code,{children:".Touched"})," events.)"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Point"})}),(0,s.jsxs)(n.td,{children:["Only representative points (e.g., center or probes) need to be inside. Extremely fast, works best with ",(0,s.jsx)(n.code,{children:"Efficient"})," detection."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"detectioncoverage",children:"DetectionCoverage"}),"\n",(0,s.jsx)(n.p,{children:"Specifies which parts of a target are considered during detection."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Center"})}),(0,s.jsx)(n.td,{children:"Only checks the object\u2019s central point. Very fast, math-only."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"AllParts"})}),(0,s.jsxs)(n.td,{children:["All tracked parts must satisfy the ",(0,s.jsx)(n.code,{children:"DetectionMode"}),". Strictest and slowest option."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"AnyPart"})}),(0,s.jsxs)(n.td,{children:["At least one part must satisfy ",(0,s.jsx)(n.code,{children:"DetectionMode"}),". More lenient and performant."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"detection-extras",children:"Detection Extras"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note:"}),"\nThe following optional fields are not automatically filled and remain ",(0,s.jsx)(n.code,{children:"nil"})," unless explicitly defined:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Field"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"ExitDetectionMode"})}),(0,s.jsxs)(n.td,{children:["The ",(0,s.jsx)(n.em,{children:"DetectionMode"})," used for checking what is trying to ",(0,s.jsx)(n.strong,{children:"Exit"})," the Zone."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"ExitDetectionCoverage"})}),(0,s.jsxs)(n.td,{children:["The ",(0,s.jsx)(n.em,{children:"DetectionCoverage"})," used for checking what is trying to ",(0,s.jsx)(n.strong,{children:"Exit"})," the Zone."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"EnterDetectionMode"})}),(0,s.jsxs)(n.td,{children:["The ",(0,s.jsx)(n.em,{children:"DetectionMode"})," used for checking what is trying to ",(0,s.jsx)(n.strong,{children:"Enter"})," the Zone."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"EnterDetectionCoverage"})}),(0,s.jsxs)(n.td,{children:["The ",(0,s.jsx)(n.em,{children:"DetectionCoverage"})," used for checking what is trying to ",(0,s.jsx)(n.strong,{children:"Enter"})," the Zone."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"execution--simulation-behavior",children:"Execution & Simulation Behavior"}),"\n",(0,s.jsx)(n.h3,{id:"execution",children:"Execution"}),"\n",(0,s.jsx)(n.p,{children:"Determines how zone evaluation logic is executed internally."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Serial"})}),(0,s.jsxs)(n.td,{children:["Runs all checks on a single thread. Allows manual stepping via ",(0,s.jsx)(n.code,{children:"Zone:Step(...)"})," when ",(0,s.jsx)(n.code,{children:"ManualStepping = true"}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Parallel"})}),(0,s.jsx)(n.td,{children:"Uses Roblox Actors for concurrent evaluation. Runs automatically and scales best for many Zones. Manual stepping not supported."})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"simulation",children:"Simulation"}),"\n",(0,s.jsx)(n.p,{children:"Specifies which stage of the Roblox simulation pipeline the Zone runs during."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"PostSimulation"})}),(0,s.jsx)(n.td,{children:"Executes after physics updates. Good for effects based on final part positions."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"PreSimulation"})}),(0,s.jsx)(n.td,{children:"Runs before physics; ideal for setting up constraints or forces."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"PreRender"})}),(0,s.jsxs)(n.td,{children:["Runs before rendering (client-side only). On the server, coerced to ",(0,s.jsx)(n.code,{children:"PostSimulation"}),"."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"bounds-configuration",children:"Bounds Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"bounds",children:"Bounds"}),"\n",(0,s.jsx)(n.p,{children:"Defines how the Zone determines its bounding volume."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Automatic"})}),(0,s.jsx)(n.td,{children:"Auto-selects a bounding model (box, sphere, or per-part) based on container geometry."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"BoxExact"})}),(0,s.jsx)(n.td,{children:"Creates a precise rotated box that fits the ZoneContainer. No instance unless explicitly defined."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"BoxVoxel"})}),(0,s.jsxs)(n.td,{children:["Like ",(0,s.jsx)(n.code,{children:"BoxExact"})," but aligns to the voxel grid for grid-based zones."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"PerPart"})}),(0,s.jsxs)(n.td,{children:["Evaluates each contained ",(0,s.jsx)(n.code,{children:"BasePart"})," or ",(0,s.jsx)(n.code,{children:"{CFrame, Size}"})," entry individually, combining their bounds to form the Zone."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"updatedetection-frequency",children:"Update/Detection Frequency"}),"\n",(0,s.jsx)(n.h3,{id:"rate",children:"Rate"}),"\n",(0,s.jsx)(n.p,{children:"Sets how frequently the Zone evaluates entries, exits, or triggers."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Mode"}),(0,s.jsx)(n.th,{children:"Step Period"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Slow"})}),(0,s.jsx)(n.td,{children:"\u2248 1.0 s"}),(0,s.jsx)(n.td,{children:"Low-frequency updates; best for large or low-priority zones."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Moderate"})}),(0,s.jsx)(n.td,{children:"\u2248 0.5 s"}),(0,s.jsx)(n.td,{children:"Medium-frequency; general-purpose default."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Fast"})}),(0,s.jsx)(n.td,{children:"\u2248 0.1 s"}),(0,s.jsx)(n.td,{children:"High-frequency checks for responsive gameplay interactions."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Immediate"})}),(0,s.jsx)(n.td,{children:"0 s"}),(0,s.jsx)(n.td,{children:"Evaluates every frame or heartbeat slice. Continuous mode; most CPU-intensive."})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"event-listening--manual-stepping",children:"Event Listening & Manual Stepping"}),"\n",(0,s.jsx)(n.h3,{id:"rate-1",children:"Rate"}),"\n",(0,s.jsx)(n.p,{children:"Sets how frequently the Zone evaluates entries, exits, or triggers."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"NoZonePartPropertyListening"})}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"Disables automatic property change monitoring on ZoneParts (e.g., Size or CFrame). When true, Zones will not auto-update their bounds."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"NoZonePartAddedListening"})}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"Disables automatic updates when ZoneParts are added or removed from a ZoneContainer folder or model."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"ManualStepping"})}),(0,s.jsx)(n.td,{children:"boolean"}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsxs)(n.td,{children:["Only valid for ",(0,s.jsx)(n.code,{children:"Execution = Serial."})," Enables manual stepping via ",(0,s.jsx)(n.code,{children:"Zone:Step(DeltaTime)"})," to control when Zone evaluations occur."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"example-zoneconfig-usage",children:"Example ZoneConfig Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-lua",children:"--!strict\n\n-- Require the Zoner Module:\nlocal Zoner = require(script.Parent.Vendor.Zoner)\n\n-- Reference a Part Box BasePart in Workspace to use as a Zone reference:\n-- (If enabled, Zoner will automatically update as the ZonePart moves or changes size)\nlocal ZoneBox: BasePart = workspace.Box\n\n-- Define a ZoneConfig table:\n-- Any of the following can be left blank, you don\u2019t even need to use one:\nlocal ZoneConfig: Zoner.ZoneConfig = {\n\tDetectionCoverage = Zoner.Enum.DetectionCoverage.Center;\n\tDetectionMethod   = Zoner.Enum.DetectionMethod.Efficient;\n\tDetectionMode     = Zoner.Enum.DetectionMode.Point;\n\n\tSimulation = Zoner.Enum.Simulation.PostSimulation;\n\tBounds     = Zoner.Enum.Bounds.BoxExact;\n\tExecution  = Zoner.Enum.Execution.Parallel;\n\tRate       = Zoner.Enum.Rate.Immediate;\n\n\tNoZonePartPropertyListening = false;\n\tNoZonePartAddedListening    = false;\n\tManualStepping              = false;\n}\n\n-- Create the Zone Object using the ZoneBox and ZoneConfig:\nlocal Zone_From_Part: Zoner.Zone = Zoner.New(ZoneBox, ZoneConfig)\n\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Any blank field in ZoneConfig defaults to DEFAULT_ZONE_CONFIG."}),"\n",(0,s.jsx)(n.li,{children:"Optional fields (Enter/ExitDetectionMode and Coverage) are nil by default."}),"\n",(0,s.jsx)(n.li,{children:"Event listening flags allow performance tuning for static zones."}),"\n",(0,s.jsx)(n.li,{children:"ManualStepping provides full control for serialized simulation updates."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This configuration gives you precise control over how Zones detect, simulate, and update\u2014all within the Zoner framework."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);