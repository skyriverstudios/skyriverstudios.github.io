"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[577],{5564:e=>{e.exports=JSON.parse('{"functions":[{"name":"NewFromContainer","desc":"Creates a new Zone from a part, model, folder, config, or a list of zone boxes.\\n\\t","params":[{"name":"ZoneContainer","desc":"Boundaries of the zone.","lua_type":"ZoneContainer"},{"name":"ZoneConfig","desc":"Optional zone tuning configs.","lua_type":"ZoneConfig?"}],"returns":[{"desc":"The constructed zone object.","lua_type":"Zone"}],"function_type":"static","source":{"line":1224,"path":"src/init.luau"}},{"name":"New","desc":"Creates a new Zone from a part, model, folder, config, or a list of zone boxes.","params":[{"name":"ZoneContainer","desc":"Boundaries of the zone.","lua_type":"ZoneContainer"},{"name":"ZoneConfig","desc":"Optional zone tuning configs.","lua_type":"ZoneConfig?"}],"returns":[{"desc":"The constructed zone object.","lua_type":"Zone"}],"function_type":"static","source":{"line":1238,"path":"src/init.luau"}},{"name":"NewZoneFromRegion","desc":"Creates a new zone from a region defined by a CFrame and Size vector.","params":[{"name":"RegionCFrame","desc":"Position and rotation of the region.","lua_type":"CFrame"},{"name":"RegionSize","desc":"Dimensions of the region.","lua_type":"Vector3"},{"name":"ZoneConfig?","desc":"Optional configuration.","lua_type":"ZoneConfig"}],"returns":[{"desc":"The constructed region zone.","lua_type":"Zone"}],"function_type":"static","source":{"line":1254,"path":"src/init.luau"}},{"name":"NewZoneFromBox","desc":"Creates a new zone from a box defined by a CFrame and Size vector.","params":[{"name":"BoxCFrame","desc":"Position and rotation of the region.","lua_type":"CFrame"},{"name":"BoxSize","desc":"Dimensions of the region.","lua_type":"Vector3"},{"name":"ZoneConfig?","desc":"Optional configuration.","lua_type":"ZoneConfig"}],"returns":[{"desc":"The constructed region zone.","lua_type":"Zone"}],"function_type":"static","source":{"line":1270,"path":"src/init.luau"}},{"name":"RelocateZonerFolder","desc":"Relocates the Zoner Folder which stores the Zone Instances","params":[{"name":"Location","desc":"the Location to send the Folder (usually a service)","lua_type":"Instance?"}],"returns":[],"function_type":"static","source":{"line":1282,"path":"src/init.luau"}},{"name":"CreateGroup","desc":"Creates a new Zone Group to be bound to:","params":[{"name":"self","desc":"The current Zoner context.","lua_type":"Zoner"},{"name":"GroupName","desc":"Name to store as.","lua_type":"string"},{"name":"Properties","desc":"Properties associated with this group","lua_type":"ZoneGroupProperties"}],"returns":[],"function_type":"static","source":{"line":1296,"path":"src/init.luau"}}],"properties":[{"name":"ZONER_COLLISION_GROUP","desc":"The collision group string used by Zoner internally for ZoneParts\\n\\nAccessed: `Zoner.ZONER_COLLISION_GROUP`","lua_type":"string","tags":["collision_groups"],"readonly":true,"source":{"line":161,"path":"src/init.luau"}}],"types":[{"name":"ZoneConfig","desc":"","fields":[{"name":"DetectionCoverage","lua_type":"DetectionCoverage?","desc":""},{"name":"DetectionMethod","lua_type":"DetectionMethod?","desc":""},{"name":"DetectionMode","lua_type":"DetectionMode?","desc":""},{"name":"Simulation","lua_type":"Simulation?","desc":""},{"name":"Execution","lua_type":"Execution?","desc":""},{"name":"Bounds","lua_type":"Bounds?","desc":""},{"name":"Rate","lua_type":"Rate?","desc":""},{"name":"ExitDetectionMode","lua_type":"DetectionMode?","desc":""},{"name":"ExitDetectionCoverage","lua_type":"DetectionCoverage?","desc":""},{"name":"EnterDetectionMode","lua_type":"DetectionMode?","desc":""},{"name":"EnterDetectionCoverage","lua_type":"DetectionCoverage?","desc":""},{"name":"NoZonePartPropertyListening","lua_type":"boolean?","desc":""},{"name":"NoZonePartAddedListening","lua_type":"boolean?","desc":""},{"name":"ManualStepping","lua_type":"boolean?","desc":""}],"tags":["public_types"],"source":{"line":243,"path":"src/init.luau"}},{"name":"ZoneContainer","desc":"A type of Zone \\"Part\\". Instanceless representation of a single Zone Box","lua_type":"(Model | Folder | BasePart | {BasePart} | {[string]: BasePart} | ZoneBoxes )","tags":["public_types"],"source":{"line":252,"path":"src/init.luau"}},{"name":"ZoneBox","desc":"A type of Zone \\"Part\\". Instanceless representation of a single Zone Box","lua_type":"{CFrame: CFrame, Size: Vector3}","tags":["private_types"],"source":{"line":21,"path":"src/Types/init.luau"}},{"name":"ZoneBoxs","desc":"An array of ZoneBoxes. Useful to create multiple, instanceless Zone boxes as one container","lua_type":"{ZoneBox}","tags":["private_types"],"source":{"line":30,"path":"src/Types/init.luau"}}],"name":"Zoner","desc":"**Zoner** is the high-performance zone manager for your experience \u2014 a **per-run-context singleton**\\n(one on Server, one on Client) that constructs zones, routes zone updates, and scales detection across\\nActors for parallel execution.\\n\\n**What it is**\\n- A **module-as-table facade**: you require it once and call its exported factories\\n  (`New`, `NewFromRegion`, `NewZoneFromBox`) instead of instantiating classes yourself.\\n- Internally, it owns a private `ZonerFolder` with:\\n  - `Holders/` \u2192 a pool of **ZonerActor** (parallel) and **ZonerGroup** (serial) holders.\\n  - `Groups/`  \u2192 group containers whose attributes mirror group properties and zone IDs.\\n- A global **Tracker Registry** via `SharedTableRegistry` for lightweight, cross-script tracking.\\n\\n**How it works**\\n- Creating a zone picks a holder type from `ZoneConfig.Execution` (Parallel \u2192 Actor, Serial \u2192 Group),\\n  provisions/loads holders as needed, and balances **capacity** automatically. Each holder\u2019s `Ids`\\n  attributes mirror live zone membership, while an internal cache maps identifiers \u2192 zone objects for O(1) access.\\n- Updates propagate through attribute changes and bindables (`Zone_Update`, `TrackerId_*`) without yielding.\\n\\n**Detection & Bounds**\\n- Build zones from parts/models/folders **or** from **partless boxes** (`CFrame` + `Size`).\\n- Tunable `DetectionCoverage`, `DetectionMethod`, `DetectionMode`, `Simulation`, `Bounds`, and `Rate`\\n  with smart defaults. When `DetectionMethod.Automatic`, Zoner selects an efficient strategy; complex\\n  modes create internal parts only when required.\\n\\n**VM / Actor model**\\n- Each **ZonerActor** runs the engine script for the current run context and processes a slice of zones\\n  **in parallel**; capacities **auto-scale** with configured thread limits.\\n- The `Groups/` container is designed to be **registered in each VM** (per Actor) so group attributes\\n  and zone IDs stay **automatically synchronized** across Zoner Actor VMs, making group properties easy\\n  to read anywhere they are required.\\n\\n**Public surface**\\n- `New`, `NewFromRegion`, `NewZoneFromBox` \u2014 zone factories returning `Zone` objects.\\n- `CreateGroup` \u2014 registers a group; its properties and membership are exposed via attributes for all VMs.\\n- `RelocateZonerFolder` \u2014 safely re-parents the internal folder (server-side).\\n- `Enum` \u2014 public enums used by configs.\\n- `ZONER_COLLISION_GROUP` \u2014 collision group name used for internal ZoneParts.\\n\\n**Lifecycle**\\n- Zoner is created at require-time; call the factory functions directly.\\n- Zones can be destroyed individually; if this script is removed, Zoner cleans itself up.\\n\\nExample:\\n```lua\\n--!strict\\n\\n-- Require the Zoner Module:\\nlocal Zoner = require(script.Parent.Vendor.Zoner)\\n\\n-- Reference a Part Box BasePart in Workspace to use as a Zone reference:\\n-- (If enabled, Zoner will automatically update as the ZonePart moves or changes size)\\nlocal ZoneBox: BasePart = workspace.Box\\n\\n-- Define a ZoneConfig table:\\n-- Any of the following can be left blank, you dont even need to use one:\\nlocal ZoneConfig: Zoner.ZoneConfig = {\\n\\tDetectionCoverage = Zoner.Enum.DetectionCoverage.Center;\\n\\tDetectionMethod   = Zoner.Enum.DetectionMethod.Efficient;\\n\\tDetectionMode     = Zoner.Enum.DetectionMode.Point;\\n\\t\\n\\tSimulation = Zoner.Enum.Simulation.PostSimulation;\\n\\tBounds     = Zoner.Enum.Bounds.BoxExact;\\n\\tExecution  = Zoner.Enum.Execution.Parallel;\\n\\tRate       = Zoner.Enum.Rate.Immediate;\\n\\n\\tNoZonePartPropertyListening = false;\\n\\tNoZonePartAddedListening    = false;\\n\\tManualStepping              = false;\\n}\\n\\n-- Create the Zone Object using the ZoneBox and ZoneConfig:\\nlocal Zone_From_Part: Zoner.Zone = Zoner.New(ZoneBox, ZoneConfig)\\n\\n-- Connect to the PlayerEntered Signal:\\n-- Returns connection so you can disconnect if youd like:\\nlocal PlayerEntered_Connection = \\n\\tZone_From_Part.PlayerEntered:Connect(function(Player: Player) \\n\\t\\tprint(`{Player.Name} Entered Zone`)\\n\\tend)\\n\\n-- Connect to the PlayerExited Signal:\\n-- Returns connection so you can disconnect if youd like:\\nlocal PlayerExited_Connection = \\n\\tZone_From_Part.PlayerExited:Connect(function(Player: Player) \\n\\t\\tprint(`{Player.Name} Exited Zone`)\\n\\tend)\\n\\n```","source":{"line":126,"path":"src/init.luau"}}')}}]);